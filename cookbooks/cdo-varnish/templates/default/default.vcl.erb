<%
   # Generates the VCL string for each section: 'request', 'response', or 'proxy'.
   def setup_behavior(section)
     backend = section == 'response'
     proxy = section == 'proxy'
     _buf = ''
     %w(dashboard pegasus).map do |app|
       config = node['cdo-varnish']['config'][app]
%>
  <%= if_app(app, backend) %>
    if (false) {
    <% config['behaviors'].each do |behavior| %>
    } else if (<%= paths_to_regex(behavior, backend, proxy) %>) {
      <%= (proxy ? process_proxy(behavior, app) : process_cookies(behavior, backend)) %>
    <% end %>
    } else {
      <%= (proxy ? process_proxy(config['default'], app) : process_cookies(config['default'], backend)) %>
    }
  <% end %>
  }
<% _buf end %>

vcl 4.0;
include "/etc/varnish/accept-language.vcl";
import cookie;
import header;
import directors;

<%
  BACKENDS = node['cdo-varnish']['backends'].to_hash
  BACKENDS.each_pair do |id, ip|
%>
backend pegasus_<%= id %> {
  .host = "<%= ip %>";
  .port = "<%= node['cdo-apps']['pegasus']['port'] %>";
  .connect_timeout = 600s;
  .first_byte_timeout = 600s;
  .between_bytes_timeout = 600s;
}

backend dashboard_<%= id %> {
  .host = "<%= ip %>";
  .port = "<%= node['cdo-apps']['dashboard']['port'] %>";
  .connect_timeout = 600s;
  .first_byte_timeout = 600s;
  .between_bytes_timeout = 600s;
}
<%
  end
%>

sub vcl_init {
  new pegasus = directors.round_robin();
  new dashboard = directors.round_robin();
<% BACKENDS.keys.each do |id| %>
  pegasus.add_backend(pegasus_<%= id %>);
  dashboard.add_backend(dashboard_<%= id %>);
<% end %>
}

# Respond to incoming requests.
sub vcl_recv
{
  # Use "/varnishcheck" to determine if you are hitting a Varnish instance.
  if (req.method == "GET" && req.url ~ "^/varnishcheck$") {
    return(synth(200, "Varnish is ready."));
  }

  # Use "/health_check.php" to keep this instance in the load balancer.
  if (req.method == "GET" && req.url ~ "^/health_check.php$") {
    return(synth(200, "Varnish is healthy."));
  }

### REDIRECTS

  if(req.http.host ~ "\.$")
  {
    /* Don't allow domain names that end in "." */
    return(synth(751, "http://" + regsub(req.http.host, "\.$","") + req.url));
  }
  else if(req.http.host ~ "^www\.")
  {
    /* Normalize domain names to the short (non www.) form. */
    return(synth(751, "http://" + regsub(req.http.host, "^www\.","") + req.url));
  }
  <%
    # Alias the following domains to one of our primary ones.
    redirects = node['cdo-varnish']['redirects'].dup
    unless rack_env?(:production)
      # Redirect e.g. [env].studio.code.org to [env]-studio.code.org
      redirects.merge!(Hash[*%w(studio i18n al ar br italia ro eu uk za).map{|x|["#{node.chef_environment}.#{x}.code.org", "#{node.chef_environment}-#{x}.code.org"]}.flatten])
    end
    redirects.each_pair do |domain,site|
  %>else if(req.http.Host == "<%= domain %>")
  {
    /* <%= domain %> redirects to <%= site %> */
    return(synth(751, "https://<%= site %>" + req.url));
  }
  <% end%>
  # Redirect http to https
  if(req.http.X-Forwarded-Proto !~ "(?i)https") {
    return(synth(751, "https://" + req.http.host + req.url));
  }
###

  cookie.parse(req.http.Cookie);

### Accept-Language HEADER

  C{
      vcl_rewrite_accept_language(ctx);
  }C

  /*
  ** Convert language cookie into X-Varnish-Accept-Language header
  */
<%
i = 0
node['cdo-apps']['i18n']['languages'].to_hash.keys.each do |language|
  js = (i += 1) != 1 ? '  else ' : '  '
  js.concat("if(req.http.Cookie ~ \"language_=#{language}\") {\n    set req.http.X-Varnish-Accept-Language = \"#{language}\";\n  }\n")
%><%= js %><%
end
%>
###

### PROXIES
<%= setup_behavior 'proxy' %>
###

### REQUEST COOKIE FILTER
# Only apply cookie filter to cached HTTP methods.
if(req.method == "GET" || req.method == "HEAD") {
<%= setup_behavior 'request' %>
  if (req.http.Cookie) {
    set req.http.Cookie = cookie.get_string();
    if (req.http.Cookie == "") {
      unset req.http.Cookie;
    }
  }
}
###
  # Pass-through to builtin.
}

# Handle the HTTP request coming from our backend
# beresp == Back-end response from the web server.
sub vcl_backend_response {

### RESPONSE COOKIE FILTER
# Only apply cookie filter to cached HTTP methods.
if(bereq.method == "GET" || bereq.method == "HEAD") {
<%= setup_behavior 'response' %>
}
###

  if (beresp.http.Cache-Control) {
    # Cache-Control: max-age directive overrides the Expires header.
    # This line is not strictly necessary, but appropriate for a default http-cache config.
    unset beresp.http.Expires;
  }

  # Keep all objects for 1h longer in the cache than their TTL specifies.
  # So even if HTTP objects are expired (they've passed their TTL), we can still use them in case all backends go down.
  # Old content to show is better than no content at all (or an error page).
  # Ref: https://www.varnish-cache.org/docs/4.0/users-guide/vcl-grace.html
  set beresp.grace = 1h;

  # Pass-through to builtin.
}

sub vcl_deliver {
  # Set a header to track a cache HIT/MISS.
  if (obj.hits > 0) {
    set resp.http.X-Varnish-Cache = "HIT";
  }
  else {
    set resp.http.X-Varnish-Cache = "MISS";
  }

  set resp.http.X-Varnish-Node = "<%= node.name %>";
  # Pass-through to builtin.
}

# Handle redirects
sub vcl_synth {
  if(resp.status == 750) {
    set resp.http.Location = resp.reason;
    set resp.status = 302;
    return(deliver);
  }

  if(resp.status == 751) {
    set resp.http.Location = resp.reason;
    set resp.status = 301;
    return(deliver);
  }
}
