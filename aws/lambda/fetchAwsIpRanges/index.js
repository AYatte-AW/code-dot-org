const Github = require('github'),
  request = require('request'),
  async = require('async');

const IP_RANGES_URL = 'https://ip-ranges.amazonaws.com/ip-ranges.json';
const NOT_MODIFIED = 'Not modified';

/**
 * Lambda function that fetches and processes updated Amazon IP-ranges,
 * and creates a new GitHub PR with updated content.
 */
exports.handler = function (event, context, callback) {
  let newBranch,
    commitMessage,
    baseCommit,
    newContent,
    oldContent,
    oldContentSha,
    pullRequest;

  const user = 'deploy-code-org',
    reviewer = 'wjordan',
    owner = 'code-dot-org',
    repository = 'code-dot-org',
    baseBranch = 'staging',
    path = 'lib/cdo/trusted_proxies.json',
    github = new Github(),
    gh = github.gitdata,
    pr = github.pullRequests;

  github.authenticate({
    type: "basic",
    username: user,
    password: process.env.GITHUB_TOKEN
  });

  // Merge owner/repo keys into provided object.
  let repo = obj => Object.assign({owner: owner, repo: repository}, obj);

  // Generic error-handling for github callbacks.
  let go = (cb, f) => ((err, data) => {
    if (err) {
      cb(err);
    } else {
      if (f) {f(data);}
      cb(null);
    }
  });

  async.waterfall([
    cb => async.parallel([
      // Get IP-range JSON from AWS.
      cb2 => request(IP_RANGES_URL, (error, response, body) => {
        if (error) { return cb2(error); }
        const info = JSON.parse(body);
        const output = {
          comment: `Generated by fetchAwsIpRanges at ${new Date().toISOString()} from ${IP_RANGES_URL}`,
          syncToken: info.syncToken,
          createDate: info.createDate,
          ranges: info.prefixes
            .filter((range) => range.service === 'CLOUDFRONT')
            .map((range) => range.ip_prefix)
        };
        newBranch = `AwsIpRanges-${output.syncToken}`;
        commitMessage = `AwsIpRanges: sync to ${output.syncToken}`;
        newContent = JSON.stringify(output, null, 2) + '\n';
        cb2(null);
      }),

      // Get file content from the repo.
      cb2 => github.repos.getContent(
        repo({path: path}),
        go(cb2, data => {
          oldContent = Buffer.from(data.data.content, 'base64').toString();
          oldContentSha = data.data.sha;
        })
      ),

      // Get base branch commit hash.
      cb2 => gh.getReference(
        repo({ref: `heads/${baseBranch}`}),
        go(cb2, data => baseCommit = data.data.object.sha)
      )
    ], err => cb(err)),

    // Abort if the syncToken timestamp isn't newer
    // or if the IP-range count is the same.
    cb => {
      let e = null,
        jsContent = JSON.parse(newContent),
        jsOldContent = JSON.parse(oldContent);
      if (jsContent.syncToken <= jsOldContent.syncToken ||
        (jsContent.ranges.length === jsOldContent.ranges.length)
      ) {
        e = NOT_MODIFIED;
      }
      cb(e);
    },

    // Create a new branch.
    cb => gh.createReference(
      repo({
        ref: `refs/heads/${newBranch}`,
        sha: baseCommit
      }),
      go(cb)
    ),

    // Commit the updated file contents to the new branch.
    cb => github.repos.updateFile(
      repo({
        path: path,
        message: commitMessage,
        content: newContent.toString('base64'),
        sha: oldContentSha,
        branch: newBranch
      }),
      go(cb)
    ),

    // Create a new Pull Request with the changes.
    cb => pr.create(
      repo({
        title: commitMessage,
        head: newBranch,
        base: baseBranch,
      }),
      go(cb, data => pullRequest = data.data.number)
    ),

    // Assign a reviewer to the PR.
    cb => pr.createReviewRequest(
      repo({
        number: pullRequest,
        reviewers: [reviewer]
      }),
      go(cb)
    )
  ], err => {
    //
    if (err === NOT_MODIFIED) { err = null; }
    callback(err);
  });
};
